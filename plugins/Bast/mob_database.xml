<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, December 02, 2017, 7:32 PM -->
<!-- MuClient version 4.98 -->

<!-- Plugin "mob_database" generated by Plugin Wizard -->

<muclient>
<plugin
   name="mob_database"
   author="Gloominati"
   id="d8031569892141fe0ca6a683"
   language="Lua"
   purpose="store analytics of kills mobs"
   date_written="2017-12-02 19:30:59"
   requires="4.98"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Store info about a mob and their death.
]]>
</description>

</plugin>
'Lock' means you cannot enter until you are that level or higher.

<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Plugin help  -->
<triggers>
	<trigger
		enabled="n"
		match="'Lock' means you cannot enter until you are that level or higher."
		omit_from_output="n"
		name="disable_keyword_finder"
		group="areas_keyword"
		script="disable_keyword_finder"
		>
	</trigger>

	<trigger
		enabled="y"
		match="You flee from combat!"
		omit_from_output="n"
		name="fled"
		script="hasFled"
		>
	</trigger>

	<trigger
		enabled="y"
		match="*has fled!"
		omit_from_output="n"
		name="mob_fled"
		script="hasFled"
		>
	</trigger>

	<trigger
		enabled="y"
		match="You lose 25 exp for recalling out of combat."
		omit_from_output="n"
		name="recallflee"
		script="hasFled"
		>
	</trigger>	

	<trigger
		enabled="y"
		match="You retreat from the fight!"
		omit_from_output="n"
		name="retreatflee"
		script="hasFled"
		>
	</trigger>	

	<trigger
		enabled="y"
		match="You die."
		omit_from_output="n"
		name="died"
		script="hasFled"
		>
	</trigger>

	<trigger
		enabled="n"
		match="^\[.*?\]\s?\>(?:\*\[NOEXP\]\* )?$"
		regexp="y"
		omit_from_output="n"
		name="clear_mob"
		script="clearMob"
		>
	</trigger>

	<trigger
		enabled="n"
		match="^\s+(?P<min_level>\d+)\s+(?P<max_level>\d+)\s+(?:(?P<locked>\d+)\s+)?(?P<keyword>\w+)\s+(?P<name>.+?)$"
		regexp="y"
		omit_from_output="n"
		name="fill_queue"
		group="areas_keyword"
		script="fill_queue"
		>
	</trigger>
</triggers>

<aliases>
  <alias
   script="OnHelp"
   match="mob_database:help"
   enabled="y"
  >
  </alias>

<alias
   match="^mobdb info (?P<table>.+?)$"
   enabled="y"
   sequence="100"
   script="getGMCPInfo"
   regexp="y"
></alias>

<alias
   match="mobdb clear"
   enabled="y"
   sequence="100"
   script="hasFled"
></alias>

<alias
   match="^mobdb sel (?P<mob>.+?)$"
   enabled="y"
   sequence="100"
   script="selectMob"
   regexp="y"
></alias>

<alias
   match="^mobdb insert (?P<mob>.+?)$"
   enabled="y"
   sequence="100"
   script="manualInsert"
   regexp="y"
></alias>

<alias
   match="^mobdb print \'(?P<mob>.+?)\' \'(?P<zone>.+?)\'$"
   enabled="y"
   sequence="100"
   script="manualPrintMobTable"
   regexp="y"
></alias>

<alias
   match="^mobdb mapper \'(?P<mob>.+?)\' \'(?P<zone>.+?)\'$"
   enabled="y"
   sequence="100"
   script="executeMapper"
   regexp="y"
></alias>

<alias
   match="mobdb showTriggers"
   enabled="y"
   sequence="100"
   script="showTriggers"
></alias>

<alias
   match="areas keyword"
   enabled="y"
   sequence="100"
   script="areas_keyword_overload"
></alias>

<alias
   match="ccon"
   enabled="y"
   sequence="100"
   script="considerOverloadStart"
></alias>

<alias
   match="econ"
   enabled="y"
   sequence="100"
   script="considerOverloadEnd"
></alias>

</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require "var"
require "serialize"
require "commas"
require "pluginhelper"
require "verify"
require 'colours'
require 'tprint'
require 'sqlitedb'
require 'aardutils'
require 'tablefuncs'
require "gmcphelper"

MobDB = Sqlitedb:subclass()

dead_target = {
	quest = "^QUEST\\: You have almost completed your QUEST\\!$",
	cp = "^Congratulations\\, that was one of your CAMPAIGN mobs\\!$",
	gq = "^Congratulations\\, that was one of the GLOBAL QUEST mobs\\!$",
}

death_knells = {
	-- weapons
  bash = "^(.+?) crumbles as (?:\\w+) is battered to death!!$",
  pierce = "^(.+?) is slain by a final deadly stab!!$",
  slash = "^(.+?) is slain by a final deadly slash!!$",
  dead = "^(.+?) is DEAD!!?$",
  poly = "^(.+?) dead as (?:\\w+) mind is destroyed\\!\\!$",
    -- elements
  megablast = "^(.+?) is destroyed by the blast!!$",
  frozen = "^(.+?) goes stiff as (?:\\w+) is frozen to death!!$",
  water = "^(.+?) is battered to death by the force of the water\\!$",
  fire = "^(.+?) screams as the flames engulf (?:\\w+)\\!\\!",
	-- misc
  fetch = "^In an explosion of energy\\, Fetch\\, the fallen lord is gone\\.$",
}

mob_regex_pattern = "(?:.*?)?(?:\\s?(?P<name>[\\w\\s\\,\\-\\'\\.]+))"

consider_flags = {
	"You would stomp %s into the ground\\.",
	"%s would be easy\\, but is it even worth the work out\\?",
	"No Problem\\! %s is weak compared to you\\.",
	"%s looks a little worried about the idea\\.",
	"%s should be a fair fight\\!",
	"%s snickers nervously\\.",
	"%s chuckles at the thought of you fighting (?:\\w+)\\.",
	"Best run away from %s while you can\\!",
	"Challenging %s would be either very brave or very stupid\\.",
	"%s would crush you like a bug\\!",
	"%s would dance on your grave\\!",
	"%s says \\'BEGONE FROM MY SIGHT unworthy\\!\\'",
	"You would be completely annihilated by %s\\!",
	"%s has divine protection\\.",
	"If you killed %s, who would serve (?:\\w+) customers\\?",
	"(?:[\\w\\s]+) would not approve of you killing %s\\!",
}

function donothing(args)

end

function MobDB:initialize(args)
	super(self, args)
	self.dbname = "\\mobs.db"
	self.version = 0
	Note( "Initializing MobDB" )
	
	local err = self:addtable('mobs', [[CREATE TABLE mobs(
		mob_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
		mob_name TEXT NOT NULL,
		zone_name TEXT NOT NULL,
		UNIQUE(mob_name, zone_name)
	)]], nil, nil, 'mob_id')
	
	Note( "MobDB:addTable mobs err = ", err )
	
	local err = self:addtable('rooms', [[CREATE TABLE rooms(
		room_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
		room_number INT NOT NULL,
		mob_id INT NOT NULL,
		frequency INT NOT NULL,
		FOREIGN KEY(mob_id) REFERENCES mobs(mob_id)
		UNIQUE(room_number, mob_id)
	)]], nil, nil, 'room_id')

	Note( "MobDB:addTable rooms err = ", err )
	
		local err = self:addtable('zones', [[CREATE TABLE zones(
		keyword TEXT NOT NULL PRIMARY KEY,
		name TEXT NOT NULL UNIQUE,
		min_level INT NOT NULL,
		max_level INT NOT NULL,
		locked INT
	)]], nil, nil, 'zone_id')

	Note( "MobDB:addTable zones err = ", err )
	self:postinit()
end --MobDB:initialize

function MobDB:turnonpragmas()
  -- PRAGMA foreign_keys = ON;
  self.db:exec("PRAGMA foreign_keys=1;")
  -- PRAGMA journal_mode=WAL
  self.db:exec("PRAGMA journal_mode=WAL;")
end

function MobDB:add_zone_keywords( keyword, table )
	if self:open('add_zone_keywords' ) then
		local locked = table.locked
		if locked == "" or locked == nil then locked = 0 end
		local sqlcmd = string.format( ' INSERT INTO zones VALUES ( "%s", "%s", %s, %s, %s ) ', keyword, clean_sql_cmd( table.name ), table.min_level, table.max_level, locked )
		local err = self:execute_query ( sqlcmd )
		self:close('add_zone_keywords')
	end
	return err
end

function MobDB:add_mob( mob, room_number, zone_name )
	local mob_id = self:select_mob_id( mob, zone_name )
	
	if mob_id == "" or mob_id == nil then
		return self:insert_mob_room( mob, room_number, zone_name )
	else
		local current_room = self:select_room( mob_id, room_number )
		if current_room == "" or current_room == nil then 
			return self:insert_room ( room_number, mob_id, 1 )
		else
			return self:update_room_frequency( current_room.room_id, current_room.frequency + 1 )
		end
	end
end

function MobDB:insert_mob_room( mob_name, room_number, zone_name)
		local results = self:insert_mob( mob_name, zone_name )
		if results == 5 then return 5 end
		
		local mob_id = self:select_mob_id( mob_name, zone_name )
		results = self:insert_room( room_number, mob_id, 0 )
		if results == 5 then return 5 end
	return 0
end
		
function MobDB:insert_mob( mob_name, zone_name )
  if self:open('insert_mob') then
	local stmt = string.format( 'INSERT INTO mobs (mob_name, zone_name) VALUES ("%s", "%s")', mob_name, zone_name )
	Note("Inserting mob: " .. stmt )
	local results = self:execute_query( stmt )
    self:close('insert_mob')
  end
	return results
end

function MobDB:insert_room( room_number, mob_id, frequency )
	if self:open('insert_room') then
		local stmt = string.format( 'INSERT INTO rooms (room_number, mob_id, frequency) VALUES (%s, %s, %s)', room_number, mob_id, frequency )
		Note("Inserting room: " .. stmt )
		local results = self:execute_query( stmt )
		self:close('insert_room')
	end
	return results
end

function MobDB:update_room_frequency( room_id, frequency )
	if self:open('update_room_frequency') then
		local stmt = string.format( 'UPDATE rooms SET frequency = %s WHERE room_id = %s', frequency, room_id )
		Note("Updating room: " .. stmt )
		local results = self:execute_query( stmt )
		self:close('update_room_frequency')
	end
	return results
end

-- mob_table = { mob_table = something, 
function MobDB:get_mob_rooms( mob_name, zone_name )
	local mob_table, room_table
	
	mob_table = self:get_mob( mob_name, zone_name )
	if mob_table ~= nil then room_table = self:get_rooms( mob_table.mob_id ) else return { ["error"] = "requesting this mob", ["mob_name"] = mob_name, ["zone_name"] = zone_name } end
	mob_table.rooms = room_table
	return mob_table
end

function MobDB:get_mob( mob_name, zone_name )
	local stmt = string.format( 'SELECT * FROM mobs WHERE mob_name = "%s" AND zone_name = "%s"', mob_name, zone_name )
	--Note(stmt)
	local mob_table = self:do_query( stmt )
	if isTableEmpty( mob_table ) then
		return nil
	else
		return mob_table[1]
	end	
end

function MobDB:get_rooms( mob_id )
	self:open( 'get_rooms' )
	--Note( string.format( 'SELECT * FROM rooms WHERE mob_id = %s', mob_id ) )
	local room_table = self:do_query( string.format( 'SELECT * FROM rooms WHERE mob_id = %s ORDER BY frequency DESC', mob_id ) )
	
	if isTableEmpty( room_table ) then
		return nil
	else
		return room_table
	end	
	self:close( 'get_rooms' )
end

function MobDB:get_zone( full_name )
	self:open( 'get_zone' )
	local stmt = string.format( 'SELECT * FROM zones WHERE name = "%s"', toLower( full_name ) )
	--Note( stmt )
	local zone_table = self:do_query( stmt )

	if isTableEmpty( zone_table ) then
		return nil
	else
		return zone_table[1]
	end
	self:close( 'get_zone' )
end

function MobDB:select_mob_id( mob_name, zone_name )
	--Note(string.format( 'SELECT mob_id FROM mobs WHERE mob_name = "%s" AND zone_name = "%s"', mob_name, zone_name ))	
	local mob_table = self:do_query( string.format( 'SELECT mob_id FROM mobs WHERE mob_name = "%s" AND zone_name = "%s"', mob_name, zone_name ) )
	if isTableEmpty( mob_table ) then
		Note("is empty")
		return nil
	else
		return mob_table[1].mob_id
	end
end

function MobDB:select_room( mob_id, room_number )
	local room_table = self:do_query( string.format( 'SELECT * FROM rooms WHERE mob_id = %s AND room_number = %s', mob_id, room_number ) )
	if isTableEmpty( room_table ) then
		return nil
	else
		return room_table[1]
	end
end

function MobDB:do_query( sqlstmt )
	local t = {}
	if self:open('do_query') then
		
		local stmt = self.db:prepare( sqlstmt )
		while stmt do
			local result = stmt:step ()
			
			if result == sqlite3.DONE then
				break
			end		

			-- should have ROW result
			assert (result == sqlite3.ROW, "Row not found")

			-- get all values into a table
			table.insert(t, stmt:get_named_values() )

		end -- while
	
	  --result = self:execute_query( string.format( 'SELECT * FROM mobs WHERE mob_name = "%s"', mob_name ) )
	  --Note(result)
	  self:close('do_query')
	end
	return t
end

function MobDB:update_room_ids( mob_name, room_ids)
	if self:open('update_room_ids') then
		local query = string.format( 'UPDATE mobs SET room_id = %s WHERE mob_name = "%s', room_ids, mob_name )
		
	end
end
		
function MobDB:execute_query( query )	
	local err = self.db:exec( query )
	if err ~= 0 then Note("\r\nself.db:exec return :: " .. err .. " :: " .. query) end
	return err
end

function getGMCPInfo( sName, sLine, wildcards )
  local t = wildcards.table
	local info = gmcp("char.status")
	--Note(info)
	--local s = table.concat({"this", "that", "other thing"}, ",")
	--local r = s:split(",")
	--Note(s)
	--tprint(r)
	--Note( table.concat( gmcp("char.status"), "," ) )
  --tprint( gmcp(table) )
end

function manualInsert( sName, sLine, wildcards )
	Note(wildcards.mob)
  	mob_queue.name = wildcards.mob
	mob_queue.room = getRoomNumber()
	mob_queue.zone = getZoneName()
	
	local result = db:add_mob( mob_queue.name, mob_queue.room, mob_queue.zone )
	
	if result == 5 then DoAfter ( 1/2, queue_the_mob(mob_queue) ) end
	currentEnemy = nil
end

function getRoomInfo()
  return gmcp("room.info")
end

function getZoneName()
	return getRoomInfo().zone
end

function getRoomNumber()
  return getRoomInfo().num
end

function implodeKeyValue( table )
	local string = ""
	for k in pairs (table) do
		string = string .. k .. " '" .. table[k] .. "', "
	end
	return string
end

function isTableEmpty( t )
    if next (t) ~= nil then
        return false
    else
        return true
    end
end

function updateFighting()
	local status = gmcp( "char.status")
	local enemy = toLower( status.enemy )
	if status.state == "8" then -- player is in combat'
		if enemy ~= currentEnemy then
  			print (string.rep ("-", 20))
			Note( "Updating combat" )
			Note( "oldEnemy = " .. ( currentEnemy == nil and "nil" or currentEnemy ) )
			Note( "now fighting = " .. enemy )
			if currentEnemy ~= nil then
				Note( "We still have an old enemy" )
			else
				Note( "Updating enemy" )
				currentEnemy = enemy
			end
			print (string.rep ("-", 20))
		end
	end
end

function hasFled()  	
	if currentEnemy == nil or currentEnemy == "" then return false end
	print (string.rep ("-", 20))
	Note("setting currentEnemy '" .. currentEnemy .. "' to nil")
  	print (string.rep ("-", 20))
	currentEnemy = nil
end

function OnPluginBroadcast (msg, id, name, text)
-- Look for GMCP handler.
  if (id == '3e7dedbe37e44942dd46d264') then
    if (text == "char.status") then
      updateFighting()
    end
  end

end

function string:split(sep)
   local sep, fields = sep or ":", {}
   local pattern = string.format("([^%s]+)", sep)
   self:gsub(pattern, function(c) fields[#fields+1] = c end)
   return fields
end

function toLower(str)
  return string.lower(str)
end

function selectMob(sName,sLine,wildcards)
	Note("mob: " .. wildcards.mob)
	db:select_mob(wildcards.mob)
end


db = MobDB:new{}
currentStatus = 0
currentEnemy = nil
keyword_queue = {}
mob_queue = {
	name = "", room = nil, zone = nil
}

function onMobDeath(sName,sLine,wildcards)
	if currentEnemy == nil or currentEnemy == "" then return false end
	mob_queue.name = currentEnemy
	mob_queue.room = getRoomNumber()
	mob_queue.zone = getZoneName()
	oldEnemy = currentEnemy
	if oldEnemy == nil then oldEnemy = "nil" end
	
	local result = db:add_mob( mob_queue.name, mob_queue.room, mob_queue.zone )
	
	if result == 5 then DoAfter ( 1/2, queue_the_mob(mob_queue) ) end
	
  	print (string.rep ("-", 20))
	Note("setting currentEnemy '" .. ( currentEnemy == nil and "nil" or currentEnemy ) .. "' to nil")
  	print (string.rep ("-", 20))
	currentEnemy = nil
end --function

function mobDead()
	EnableTrigger( "clear_mob", true )
end

function clearMob()
	EnableTrigger( "clear_mob", false )
	if currentEnemy == nil or currentEnemy == "" then return false end

	print (string.rep ("-", 20))
	Note("setting currentEnemy '" .. ( currentEnemy == nil and "nil" or currentEnemy ) .. "' to nil")
  	print (string.rep ("-", 20))
	currentEnemy = nil
end

function queue_the_mob(this_queue)
	local result = db:add_mob( this_queue.name, this_queue.room, this_queue.zone )
	
	if result == 5 then 
		DoAfter ( 1/2, queue_the_mob(this_queue) )
	else
		mob_queue = { name = "", room = nil, zone = nil }
		printMobTable( mob_queue.name, mob_queue.zone )
	end
end

function printMobTable( name, zone )
	local mob_table = db:get_mob_rooms( name, zone )
	tprint ( mob_table )
end

function executeMapper( sName, sLine, wildcards )
	local mid = db:select_mob_id( wildcards.mob, wildcards.zone )

	
		local room = db:get_rooms( mid )
		Note(room)
	
	Note("Mob: " .. wildcards.mob)
	Note(room[1].room_number)
	Execute("mapper goto " .. room[1].room_number )
end

function showTriggers()
	tl = GetTriggerList()
	if tl then
  		print (string.rep ("-", 20))
		Note( "Printing current triggers" )
		Note( "" )
	  for k, v in ipairs (tl) do
		Note( "match = " .. GetTriggerInfo(v, 1) ) 
		Note( "script = " .. GetTriggerInfo(v, 4) )
		Note( "enabled = " .. tostring( GetTriggerInfo(v, 8) ) )
		Note( "regexp = " .. tostring( GetTriggerInfo(v, 9) ) )
		Note( "" )
	  end  -- for
  		print (string.rep ("-", 20))
	end -- if we have any triggers
end

function manualPrintMobTable(sName,sLine,wildcards)
	printMobTable( wildcards.mob, wildcards.zone )
end

function areas_keyword_overload()
	EnableTriggerGroup( "areas_keyword", true )
	Send( "areas keyword" )
end

function disable_keyword_finder()
	EnableTriggerGroup( "areas_keyword", false )
	process_keyword_queue()
end

function fill_queue(sName,sLine,wildcards)
	key = wildcards.keyword
	keyword_queue[key] = {
		name = wildcards.name,
		min_level = wildcards.min_level,
		max_level = wildcards.max_level,
		locked = wildcards.locked,
	}
end

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- SELECT mob_id FROM mobs WHERE mob.name = name AND mob.zone = zone
-- SELECT * FROM rooms WHERE mob.id = id
-- if no mob or no room INSERT mob + room or INSERT room

consider_functions_queue = {
	both = function ( name, room, zone ) db:insert_mob_room( name, room, zone ) end,
	room = function ( room, mob_id ) db:insert_room( room, mob_id, frequency ) end
}

consider_queue = { }

function addFromConsider( name )
	local name = toLower( name )
	local zone = getZoneName()
	local room = getRoomNumber()

	local mob_id = db:select_mob_id( name, zone )

	if mob_id == "" or mob_id == nil then
		db:insert_mob_room( name, room, zone )
	else
		local room_result = db:select_room( mob_id, room )
		if room_result == "" or room_result == nil then
			db:insert_room( room, mob_id, 0 )
		end
	end
end

function onConsider( sName, sLine, wildcards )
	addFromConsider( wildcards.name )
end

function processConsiderQueue()
	if isTableEmpty( consider_queue ) then return false end
	local f, nargs

	for k, v in pairs (consider_queue ) do
		f = v.func
		nargs = 0
			for key, value in pairs ( v.args ) do
				nargs = nargs + 1
			end
		if nargs == 2 then f( v.args[1], v.args[2] )
		else if nargs == 3 then f( v.args[1], v.args[2], v.args[3] ) end
		end
	end
				
end

function considerOverloadStart()
	EnableTriggerGroup("ConsiderOverload", true)
	Send("consider")
end

function considerOverloadEnd()
	EnableTriggerGroup("ConsiderOverload", false)
	processConsiderQueue()
	consider_queue = {}
end

function clean_sql_cmd ( s )
	return toLower((s:gsub("^%s*(.-)%s*$", "%1")))
end

function process_keyword_queue()
	Note("Process queue")
	for k, v in pairs (keyword_queue) do
		Note(k)
		tprint(v)
		db:add_zone_keywords( k, v )
	end
end

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

function outsideGetZoneKeyword( name )
	return db:get_zone( toLower( name ) ).keyword
end

function outsideGetMob( name_zone )
	local t = {}
	--Note("name_zone: " .. name_zone)
	for i in string.gmatch(name_zone, "[^~]+") do
	   table.insert(t, i)
	end
	tprint(t)
	local m_name = toLower( t[1] )
	local z_name = toLower( t[2] )

	--Note("name: " .. m_name .. " zone: " .. z_name)

	local zone_results = db:get_zone( z_name )
	if zone_results == nil or zone_results == "" then return nil end
	--Note("zone_results: " .. zone_results.keyword)
	local mob_results = db:select_mob_id( m_name, zone_results.keyword )
	--Note( "mob_results: " .. mob_results )
	if mob_results == nil or mob_results == "" then
		return nil
	else
		local room_table = db:get_rooms( mob_results )
			if room_table == nil or room_table == "" then
				return 
			else
				return room_table[1].room_number
			end
	end
end

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

html_replacements = { 
   ["<"] = "&lt;",
   [">"] = "&gt;",
   ["&"] = "&amp;",
   ['"'] = "&quot;",
   }

-- fix text so that < > & and double-quote are escaped
function fixhtml (s)

  return (string.gsub (tostring (s), '[<>&"]', 
    function (str)
      return html_replacements [str] or str
    end ))

end -- fixhtml


function GeneralAdd (t, which, plural)
 
  assert (type (t) == "table", "Table must be supplied to add a " .. which)

  local k, v
  local xml = {}
  
  local send = fixhtml (t.send or "")  -- send is done differently
  t.send = nil
  
  -- turn into XML options  
  for k, v in pairs (t) do
  
    -- fix true/false to y/n
    if v == true then
      v = "y"
    elseif v == false then
      v = "n"
    end -- if true or false
    
    table.insert (xml, k .. '="' .. fixhtml (v) .. '"')
  end -- for loop
      
  assert (ImportXML (string.format (
          "<%s><%s %s ><send>%s</send></%s></%s>",
             plural,   -- eg. triggers
             which,    -- eg. trigger
             table.concat (xml, "\n"),  -- eg. match="nick"
             send,     -- eg. "go north"
             which,    -- eg. trigger
             plural)   -- eg. triggers
         ) == 1, "Import of " .. which .. " failed") 
  
end -- GeneralAdd 

function LuaAddTrigger (t)
  GeneralAdd (t, "trigger", "triggers")
end -- LuaAddTrigger

function LuaAddAlias (t)
  GeneralAdd (t, "alias", "aliases")
end -- LuaAddAlias 

function LuaAddTimer (t)
  GeneralAdd (t, "timer", "timers")
end -- LuaAddTimer 

function LuaAddMacro (t)
  GeneralAdd (t, "macro", "macros")
end -- LuaAddMacro 

for k, v in pairs ( death_knells ) do
	LuaAddTrigger {
		match = v,
		regexp = true,
		enabled = true,
		script = "mobDead"
	}
end

for k, v in pairs ( dead_target ) do
	LuaAddTrigger {
		match = v,
		regexp = true,
		enabled = true,
		script = "onMobDeath"
	}
end

for k, v in pairs ( consider_flags ) do
	local clean = string.format( v, mob_regex_pattern )
	
	LuaAddTrigger {
		match = clean,
		regexp = true,
		enabled = false,
		script = "onConsider",
		group = "ConsiderOverload"
	}
end
]]>
</script> 

</muclient>
